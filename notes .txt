// CS 235

// Notes 

// List: like a vector but control the order

// Set  #include <set> 



// Map: Map connects Keys with values, it's an important data type. A map is kind of like a vector except the index is defined by you as what ever you would like it to be.

#include <map>

map<string,int> age
age [“Mark”] =16

cout << age [“Mark”]

age.erase(“Mark”)

example 2: 

int main() 

{
	map<string,int> words;
	string word;
	while (cin>>word){

		if (words.count(word)==0)
			words[word]=1
		else
			words[word]++;

	}
	print (words);
}


// stack: data type in which you can only manipulate the top object.  .push puts an object on top, and .pop removes it (deletes it) . .top prints the top object, .empty clears the stack,  .size lists the number of items 

// Stacks are used all the time in computing the most common stack is the runtime stack which is used by the OS 



// queue #include<queue> = shows the object on top, adds objects to the bottom.
// std::queue

// add (push)(adds item to the end)
// remove (pop) ( removes an item from the front)
// front (shows front of queue)
// size

// priority queue = works like a regular queue except it sorts items by priority, priority can be determined by the user but is usually based on size.  (small items first.)



// notes for lab 2

// read a file to  a set and parse individual strings 
set<string> 

getline() could be used
or >> 


// you need to fix lowercase and uppercase discrepancies 

// isupper
// tolower

// are functions that are in the STD that will work if you put it in a loop for the whole string. 

// For each line we need to make all letters lowercase, and replace non letter characters with spaces. You can use isalpha to find out if the charaters are letters. 

// Then put the line into a stringstream and use the extraction operator >> to pull out individual words. 
// Then ask if each word that is pulled out is in the set, if it is keep scanning, if it is not, store it in a map. 

map(string,list(int))

for each( )

	printing a map= for (auto p: map)

p.first
p.second 

// you may need to make a spell checker object that will contain the dictionary set and the misspelled words map



// Recursion  

// a method (or function) that calls itself 

// make this function recursive :
int sum (int n) {
	int sum=0;
	for (int I = 0; I <= n; i++)
		sum += 1;
	return sum;
}


if (n == 0)
	return 0;
else 
	return sum (n-1) +n 

// when recuring, you must call the function in a different way. 


// The principle of induction 
// 1. show that it works for the base case
// 2. show that if it works for step k, it works for step k+1
// 3.assume that the recursive call works. (assume that if the recursive call works and make sure that the code surrounding it is built to utilize the recursion)


// When do you want to use recursion?
// 1. Recursive data
// file system folders (folders contain folders)
// arithmetic expressions (expressions contain expressions)
// programming languages (statements contain statements)

// 2. divide and conquer
// sort a pile by dividing it into smaller piles 
// solve a problem by dividing it into smaller problems 

// 3. backtracking search
// permute 
// boggle


// deep recursion: don't use recursion if the recursion is going to go really deep into the function. It will slow your program down a TON!

// Big Oh notation

// sometimes there are many ways to perform a function. You always want to pick the 
// 1.simplest
// 2.smallest
// 3.fastest

// generally, you want the fastest function. When you are trying to figure out which solution is the fastest you should think about:

// 1. measuring the run time
// 2. predicting the run time through analysis

// when analyzing code functions can be defined by algebraic expressions where constants are defined as the number of statements in a function, which are effected by loops defined as variables. When thinking about code in this way, the largest factor in a term is the most important. 

// For example: in the equation  n^2+4n+2  n^2 is the largest term and other terms can be ingnored. 

// BigOh= T(n) is 0(f(n))
// if there exist positive constants c and n0 such that 
// T(n) <=c*f{n}


// rules for bigOh

// always keep the biggest term. If determining the bigOh for a selection statement (if else) choose the biggest part or the slowest case. 


// Log10(1000) = 3
// log2(16) =4

// log base 10 = round n to the closest power of 10 and count 0s 

// 123 → round to 100 → log10(100)=2 
// 2183746058 → round to 1000000000 →  log10(1000000000) =9


// log base 2

// 2^10=1024


// Searching

//  linear search : for each I from 0 to size 1 if item equals list[i] return I. Big oh = n 

// binary search : 

// low=  index of first item in list
// high index of last item in list
// while low is <= high
// mid = index halfway between low and high 
// if item is less than list mid high = mid -1 
// else if item is greater than list[mid]
// low = mid+1 
// else 
//    return mid 
// binary is a good example of logn bigoh 


// notes for lab 3
// Boggle 

// step one given the content of the board store it into a vector <String>

// then figure out the size of the vector<string>.size()
// sqrt(9) → (don't ever use pow())
//  create a 2d vector vector<vector<String>>

// if R,C of board, return
// Add Str to word
// look for word in DICT
// look for partial word as prefix of dictionary words if word is not prefix, return
// i= set.lower_bound(word) lower bound returns an iterator 
// if i==set.end()
// {
// p=*i
// if p starts with w

// *

// for row
// for col 
// find (r,c)
// find (r,c+1)
// find (r+1,c)
// find(r+1,c+1)




// Templates:

// like a class but it should all be contained in a .h file.

// Nodes = places in a list or data type that hold data

// new = sets memory aside for something, must call delete to avoid memory leaks 
// new node *  = 

// lab 5 

// node class

// list class


// (static) Compile-Time 
// (Dynamic) Run-time 

// new allows ...

// items=new int [size]

// items is a pointer that is pointing to an array. In c++ you can treat it like it is an array so if you wanted to call the seccond
// point in an array you could use Items[1].

template <typename ItemType> // declaration of a generic item to be defined in the .cpp file this is neccisary because we need this container 
//be able to hold any spesified thing (strings, doubles, ints, consts... so on and so forth.) in your .cpp when you say vector<

class List{

private: 
	int count;
	int capacity;
	ItemType* items;

	static const int DEFAULT_SIZE = 10

public:
	List():

	count(0),
	capacity(DEFAULT_SIZE),
	Items (new ItemType[capacity])
	{} 

	void append(const ItemType& item)
	{
		if(count==capacity)
		{
			ItemType* temp = new ItemType[capacity*2];
			capacity *= 2;
			for(int i = 0; i<count; i++)
			{
				temp[i] = items[i];
				items = temp;
			}
		}
		items[count] = item;
		count++
	}

	ItemType remove()
	{
		ItemType temp = item[0];
		count--;
		for(int i = 0; i<count;i++)
		{
			items[i]=items[i+1];
			return temp;
		}
	}

	~List()
	{
		delete [] items;
	}

}


// amortized big o = when a process' average big o is constant. 

// TREES!!!! (8.1)

//Trees have nodes and links between those nodes but the tree structure is very different from a list, mainly that it is not linier 
// One node in a tree will be the root, every node in a tree has exactly one parent with the exeption of the root node 
 // Trees are naturally recursive, (trees are comprized of smaller trees)

//             A
//            / \
//           B    C
//          / \  / \
//         D   EF   G
// Root: A
// Leaves: D E F G 
// Parent of D: B
// Siblings of F: G
// ancestors of G: C, A
// Descendants of B: D , E 
// height is the distance from the farthest leaf
 // What is the height of node B: 2 or (1) 
// what is the height of a leaf node: 1 or (0)
// Depth of the root : 0 
// Depth of C: 1 
// size of the tree rooted at c: 3 
// size of the entire tree: 7


/* How a tree is constructed

each node needs space for its content, and an array or vector of pointers to children 
you could also replace that vector with just two pointers, one to the first child, and another to the next sibling. 

How would you write a code for a preorder traversal of a tree? 
a preorder set sugests that you navigate each node in the tree in a parent then child (recursive) format so
the above tree would list the nodes in the following order pre: abdecfg 

in a post order: start from the bottom and go up! post: debfgca 

Bianary Trees! 
											A
  In Bianary trees each node              /   \ 
  must be defined as either 			 B     C
  the left or the right child           / \    /                                           
  but never the middle.                D   E  F
                                          /    \ 
                                          G     H
                                           \
                                            I

 this A  is not a bianary tree, but this A is.
      |                                 /   
      B                                B

what is the preorder of the bianary tree above? ABDEGICFH
what is the postorder for this bianary tree? DIGEBHFCA
what is the inorder for this bianary tree? (left parent right) DBGIEAFHC
whiat is the levelorder for this bianary tree? ABCDEFGHI
      */
#include <iostream>
#include <queue>
using namespace std;

class Tree{


public: 
	string preorder() const
	{
		return preorder(root);
	}
	string postorder() const
	{
		return postorder(root);
	}
	string inorder() const
	{
		return inorder(root);
	}
	int size(Node* n) const 
	{
        if(n==NULL)
        	retun 0;
        else
		size(n->left)+size(n->right) +1;
	}
private:
	 struct Node{
	 string item;
	 Node* left;
	 Node* right;

	 Node(const string&item, Node* left Node* right) :

	 item(item),
	 left(left),
	 right(right)
	 {}
	string preorder(node* n) const 
	{
		stringstream out;
		if(n!=NULL) 
		{
			out << n->item;
			out << preorder(n->left);
			out << preorder(n->right);
		}
		return out.str()	
	}

	string postorder(node* n) const
	{
		string stream out;
		if (n!=NULL)
		{
			out << postorder(n->left);
			out << postorder(n->right);
			out << n->item;
		}
		return out.str();
	}

	string inorder(node* n) const 
	{
		stringstream out;
		if (n!=NULL)
		{
			out << postorder(n->left);
			out << n->item;
			out << postorder(n->right);
		}

	}
}

class Iterator
{
private:
	//std::stack<Node*> items;
	std::queue<Node*> items;
}
public:
	iterartor(Node* root) {
		if(root!= NULL)
			items.push(root);
	}
	string operator * () const{

		return items.front()->item;
	}
	void operator ++ () {
		Node* n=items.front()
		items.pop();
		if(n->left!=NULL)
			items.push(n->left);
		if(n->right!=NULL)
			items.push(n->right);
	}
}

/* 
 Bianary Search Tree: BST 0(logn)   
  defining properties: for every node in the tree, items in the left subtree are smaller, items in the right subtree are larger
  there can be no duplicates. 
  Sets and Maps are built out of these 

         example: 5
                 / \
                3   6
               / \   \
              1   4   9
               \      /
                2    7
                      \
                       8
 numbers are entered in order of insertion.
 searching these trees entails approaching a root node and asking is it < or > then moving the appropriate direction
 insterting in a tree like this involoves searching until you find the null space where the 3 goes and adding it.  
 removing would be similar to insterting in the case of leaves. you would find it, then change the pointer to null and call delete 
 on the 3. 

 removing a 1 child node : change the pointer of the parent to the grandchild.
 removing a 2 child node : use the Choose the right rule, find the smallest value in the right subtree and copy it into the 
 node that contained the parent node you are deleting, then change the pointers of any children of the smallest value in the right subtree
to point to thier grandparents. 
  AVL
  HASH

  both BST and AVL have 0(logn)
  HASH has 0(1)


*/

//psudo code for lab 6

add item

public:

 add(root, item);
 find(root, item);

private:
 void add(node*& n,ItemType item)
 {
	if(n==null)
	{
	n = new Node(item)
	}
 	else if(item< n->item)
 	{
 		add(n->left,item)
 	}
 	else if(item>n->item)
 	{
 		add(n->right,item)
 	}
 }
 bool find(node* n, ItemType item)
 {
 	if (n==NULL)
 	{
 		return false;
 	}
 	else if(item<n->itme)
 	{
 		return find(n->left,item)
 	}
 	else if (item>)
 }

/*
project 6, making a set. 

modify the main from project 5 to read in the commands.
then implement the lsit 

for the printing function you will need a queue 
you can use the linked list from lab 5 for the queue 
(add root to q, while levelsize= q.size, while queue is not empty, remove n from q, add n->left to q, add n->right to q, out << n -> item, end)


BALLANCING THE TREE 

for every node in the tree the height of the left and right trees differ by at most 1. 

for example 

       5
      / \
     4   8
    /   / \ 
   2   6   9
      /     
     7
     
     this is a ballanced AVL tree, the root (5) has 2 branches on the left, and 3 on the right 2-3 = -1, which fits the paramaters of the definition


     take a look at this tree:

     4
      \
       7
        \
         9

         this tree is not ballanced because the 4 has 0 branches on the left, 2 on the right 0-2=-2 which is >-1
         you can ballance it by rotating the tree 

         7
        / \
       4   9

       out of balance nodes will always be on the same path. 
       when rebalancing the tree, or rotating nodes, always start with the lowest nodes from the root

       steps to a rotation:

       let n be the node that is out of bablance 
       let k be the left child of     	 n 
       make the parent of n point to k instead of NULLmake n's left child pointer mpoint to K instead of NULLmake n's left child pointer point to k's right child 
       make k's right child pointer point to  n

       a double rotation would be necicary in a situation like this:

                      3
                     / \
                    2   8
                   /   / \
                  1   7   9
				     /
				    5
				     \
				      6
	   where the 6 would flip with the 5, and then the whole 7 subtree would rotate.
	     	